最近在学JAVA安全，JNI这个东西挺有意思的，一路上踩了很多坑，记录一下。

**jni_sec.CommandExecution**

```java
package jni_sec;

public class CommandExecution {
    static {
        System.loadLibrary("cmd");
    }

    public static native String exec(String cmd);

    public static void main(String[] args) {
        System.out.println(exec("dir"));
    }
}

```

编译为class文件，并添加一个头文件。

```bash
javac 
D:\java_box\java_sec_learning\src\jni_sec\CommandExecution.java  
-classpath D:\java_box\java_sec_learning\src
-h D:\java_box\java_sec_learning\src\jni_sec
```

- -classpath 表示输出.class文件的位置（具体位置为%classpath%\%package%\%CLASS_NAME%）
- -h 表示输出头文件，以及头文件的输出位置。

还可以加一个cp参数，表示在对应文件夹下查找缺失的类。

之后可以得到一个 **jni_sec_CommandExecution.h** 文件，其内容为

```cpp
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class jni_sec_CommandExecution */

#ifndef _Included_jni_sec_CommandExecution
#define _Included_jni_sec_CommandExecution
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     jni_sec_CommandExecution
 * Method:    exec
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_jni_1sec_CommandExecution_exec
  (JNIEnv *, jclass, jstring);

#ifdef __cplusplus
}
#endif
#endif
```

- 之后创建一个新的文件夹，并把该.h文件放入该文件夹
- 将java安装目录下的jni.h与jni_md.h拖入该文件夹。
- 更改.h文件的 <jni.h>为"jni.h"
- 创建 jni_sec_CommandExecution.cpp 内容如下

```cpp
//
// Created by shaob on 2020/7/22.
//

#include "jni_sec_CommandExecution.h"

//
// Created by yz on 2019/12/6.
//
#include <iostream>
#include <stdlib.h>
#include <cstring>
#include <string>

using namespace std;

JNIEXPORT jstring

JNICALL Java_jni_1sec_CommandExecution_exec
        (JNIEnv *env, jclass jclass, jstring str) {

    if (str != NULL) {
        jboolean jsCopy;
        // 将jstring参数转成char指针
        const char *cmd = env->GetStringUTFChars(str, &jsCopy);

        // 使用popen函数执行系统命令
        FILE *fd  = popen(cmd, "r");

        if (fd != NULL) {
            // 返回结果字符串
            string result;

            // 定义字符串数组
            char buf[128];

            // 读取popen函数的执行结果
            while (fgets(buf, sizeof(buf), fd) != NULL) {
                // 拼接读取到的结果到result
                result +=buf;
            }

            // 关闭popen
            pclose(fd);

            // 返回命令执行结果给Java
            return env->NewStringUTF(result.c_str());
        }

    }

    return NULL;
}
```

之后是编译文件。我用的cygwin，但是cygwin带的gcc/g++编译器是不能成功编译的（可能它面向的是Linux平台），用mingw是能成功的

具体命令如下所示
```bash
$ x86_64-w64-mingw32-g++.exe -I "$JAVA_HOME\\include" -I "$JAVA_HOME\\include\\win32" -shared -o cmd.dll jni_sec_CommandExecution.cpp
```

此时应该可以得到一个.dll文件。其命名应该与static中写明的loadLibrary中一样。我这里是`cmd.dll`

将该dll文件放到系统PATH的目录底下，或者自己创建一个目录，并在编译的时候设置`Djava.library.path`参数


我放到了`lib\`目录下，在此处这样设置，即可成功运行结果

![title](https://leanote.com/api/file/getImage?fileId=5f17da8aab644149e60015dd)


![title](https://leanote.com/api/file/getImage?fileId=5f17daa7ab644149e60015df)

